// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc.team3543.robot.subsystems.drive;

import java.util.Optional;

import org.usfirst.frc.team3543.robot.Calibration;
import org.usfirst.frc.team3543.robot.Wiring;
import org.usfirst.frc.team3543.robot.subsystems.BaseSubsystem;

import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.NeutralMode;
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
import com.team254.frc2017.Constants;
import com.team254.frc2017.Kinematics;
import com.team254.frc2017.RobotState;
import com.team254.frc2017.subsystems.Drive;
import com.team254.frc2017.subsystems.Drive.DriveControlState;
import com.team254.lib.util.DriveSignal;
import com.team254.lib.util.control.Lookahead;
import com.team254.lib.util.control.PathContainer;
import com.team254.lib.util.control.PathFollower;
import com.team254.lib.util.drivers.NavX;
import com.team254.lib.util.math.RigidTransform2d;
import com.team254.lib.util.math.Rotation2d;
import com.team254.lib.util.math.Twist2d;
import com.usfirst.frc.team3543.robot.pathrecording.RecordedPath;
import com.team254.lib.util.control.Path;

import edu.wpi.first.wpilibj.AnalogGyro;
import edu.wpi.first.wpilibj.CounterBase.EncodingType;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.PIDController;
import edu.wpi.first.wpilibj.PIDSourceType;
import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.command.PIDSubsystem;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import team3543.robot.sub.drive.DriveConstants;
import team3543.robot.sub.drive.DriveUtils;


/**
 * Main DriveLine.  Packages the 4 drive CANTalons, left/right quadrature encoders and gyro
 * 
 * Note that all the commands that use the drive line use high-level methods in this
 * class, they don't tale to the RobotDrive (etc.) directly.  Putting in high-level
 * methods is a good idea because it allows you to abstract the underlying actuators
 * from the commands.
 * 
 * @author MK
 *
 */
@SuppressWarnings("deprecation")
public class DriveLine extends BaseSubsystem implements DriveLineLog {
	// Configuration keys
	public static final String SENSITIVITY = "driveline.sensitivity";	
	public static final String EXPIRATION = "driveline.expiration";	
	public static final String MAX_OUTPUT = "driveline.max_output";	

	public static final String LEFT_FRONT_MOTOR_PORT = "driveline.motor.left_front";
	public static final String LEFT_BACK_MOTOR_PORT = "driveline.motor.left_back";
	public static final String RIGHT_FRONT_MOTOR_PORT = "driveline.motor.right_front";
	public static final String RIGHT_BACK_MOTOR_PORT = "driveline.motor.right_back";
	public static final String GYRO_PORT = "driveline.gyro.port";
	public static final String GYRO_SENSITIVITY = "driveline.gyro.sensitivity";
	public static final String LEFT_ENCODER_DISTANCE_PER_PULSE = "driveline.left_encoder.distance_per_pulse";	
	public static final String RIGHT_ENCODER_DISTANCE_PER_PULSE = "driveline.right_encoder.distance_per_pulse";
	public static final String LEFT_ENCODER_PORT_1 = "driveline.left_encoder.port_1";	
	public static final String LEFT_ENCODER_PORT_2 = "driveline.left_encoder.port_2";
	public static final String RIGHT_ENCODER_PORT_1 = "driveline.right_encoder.port_1";	
	public static final String RIGHT_ENCODER_PORT_2 = "driveline.right_encoder.port_2";

	// Configuration defaults
	public static final double DEFAULT_ENCODER_DISTANCE_PER_PULSE = 0.0131;
	public static final double DEFAULT_GYRO_SENSITIVITY = 0.007;
	public static final double DEFAULT_DRIVE_SENSITIVITY = 0.5;
	public static final double DEFAULT_EXPIRATION = 0.1;
	public static final double DEFAULT_MAX_OUTPUT = 1.0;
    public static final double DEFAULT_TIMER_DELAY = 0.01;	// delay passed to Timer.delay() on driveline calls
	
	// Smart Dashboard stuff
	public static final String DASHBOARD_LEFT_ENCODER_DPP = "Driveline Left Quad DPP";
	public static final String DASHBOARD_RIGHT_ENCODER_DPP = "Driveline Right Quad DPP";
	public static final String DASHBOARD_LEFT_WHEEL_DISTANCE = "Driveline Left Wheel Distance";
	public static final String DASHBOARD_RIGHT_WHEEL_DISTANCE = "Driveline Right Wheel Distance";
	
	public static final String DASHBOARD_GYRO_ANGLE = "Driveline Gyro Angle";
	
	// Properties
	private double defaultLeftEncoderDPP;
	private double defaultRightEncoderDPP;
	
	private WPI_TalonSRX leftMaster;
	private WPI_TalonSRX leftSlave;
	private WPI_TalonSRX rightMaster;
	private WPI_TalonSRX rightSlave;
	private RobotDrive robotDrive;
	private AnalogGyro analogGyro;
	private Encoder quadratureEncoderLeft;
	private Encoder quadratureEncoderRight;
	
	private double trim = 1.0;

	private double gyroSensitivity;
	private double gyroGain;	
	
	private DriveControlState mDriveControlState;

	private RecordedPath recordedPath = null;
	
	private double timerDelay = DEFAULT_TIMER_DELAY;
	
	public DriveLine() {
		super();

		// Initialize the robot
		int leftMasterMotor = Wiring.DRIVELINE_MOTOR_LEFT_FRONT;
		int leftSlaveMotor = Wiring.DRIVELINE_MOTOR_LEFT_BACK;
		int rightMasterMotor = Wiring.DRIVELINE_MOTOR_RIGHT_FRONT;
		int rightSlaveMotor = Wiring.DRIVELINE_MOTOR_RIGHT_BACK;
		int gyro = Wiring.DRIVELINE_GYRO_PORT;	
		int leftMasterEncoder = Wiring.DRIVELINE_LEFT_ENCODER_PORT_1;
		int leftSlaveEncoder = Wiring.DRIVELINE_LEFT_ENCODER_PORT_2;
		int rightMasterEncoder = Wiring.DRIVELINE_RIGHT_ENCODER_PORT_1;
		int rightSlaveEncoder = Wiring.DRIVELINE_RIGHT_ENCODER_PORT_2;

		leftMaster = new WPI_TalonSRX(leftMasterMotor);       
		leftSlave = new WPI_TalonSRX(leftSlaveMotor);		
		leftSlave.follow(leftMaster);
				
		leftMaster.setNeutralMode(NeutralMode.Brake);
		leftMaster.configOpenloopRamp(Calibration.DRIVELINE_OPEN_LOOP_RAMP, 0);
		leftMaster.set(ControlMode.PercentOutput,0);
		leftSlave.configOpenloopRamp(Calibration.DRIVELINE_OPEN_LOOP_RAMP, 0);
		
		rightMaster = new WPI_TalonSRX(rightMasterMotor);
		rightMaster.set(ControlMode.PercentOutput,0);
		rightSlave = new WPI_TalonSRX(rightSlaveMotor);
		rightSlave.follow(rightMaster);		
		rightMaster.setNeutralMode(NeutralMode.Brake);
		rightMaster.configOpenloopRamp(Calibration.DRIVELINE_OPEN_LOOP_RAMP, 0);
		rightSlave.configOpenloopRamp(Calibration.DRIVELINE_OPEN_LOOP_RAMP, 0);
						
		robotDrive = new MyRobotDrive(this, leftMaster, leftSlave, rightMaster, rightSlave);

		String name = getName();
		LiveWindow.addActuator(name, "Front Left Motor", leftMaster);
		LiveWindow.addActuator(name, "Back Left Motor", leftSlave);
		LiveWindow.addActuator(name, "Front Right Motor", rightMaster);
		LiveWindow.addActuator(name, "Back Right Motor", rightSlave);
		
		robotDrive.setSafetyEnabled(true);
		robotDrive.setExpiration(Calibration.DRIVELINE_EXPIRATION);
		robotDrive.setSensitivity(Calibration.DRIVELINE_SENSITIVITY);
		robotDrive.setMaxOutput(Calibration.DRIVELINE_MAX_OUTPUT);

		timerDelay = Calibration.DRIVELINE_TIMER_DELAY;

		analogGyro = new AnalogGyro(gyro);
		analogGyro.setSensitivity(Calibration.DRIVELINE_GYRO_SENSITIVTY);
		gyroGain = Calibration.DRIVELINE_GYRO_GAIN;		
		
		defaultLeftEncoderDPP = Calibration.DRIVELINE_LEFT_ENCODER_DPP;
		defaultRightEncoderDPP = Calibration.DRIVELINE_RIGHT_ENCODER_DPP;
		
		quadratureEncoderLeft = new Encoder(leftMasterEncoder, leftSlaveEncoder, false, EncodingType.k2X);	    	
		quadratureEncoderLeft.setDistancePerPulse(defaultLeftEncoderDPP);
		quadratureEncoderLeft.setPIDSourceType(PIDSourceType.kRate);

		quadratureEncoderRight = new Encoder(rightMasterEncoder, rightSlaveEncoder, false, EncodingType.k2X);
		quadratureEncoderRight.setDistancePerPulse(defaultRightEncoderDPP);
		quadratureEncoderRight.setPIDSourceType(PIDSourceType.kRate);

		LiveWindow.addSensor(name, "Left Quad Encoder", quadratureEncoderLeft);
		LiveWindow.addSensor(name, "Left Quad Encoder", quadratureEncoderRight);
		LiveWindow.addSensor(name, "Gyro", analogGyro);	

	}

	public WPI_TalonSRX getLeftMotor() {
		return this.leftMaster;
	}
	
	public WPI_TalonSRX getRightMotor() {
		return this.rightMaster;
	}
		
	// Put methods for controlling this subsystem
	// here. Call these from Commands.
	public void initDefaultCommand() {
		this.analogGyro.calibrate(); 	
	}

	public double getTimerDelay() {
		return this.timerDelay;
	}
	
	public void tankDrive(Joystick left, Joystick right) {
		robotDrive.tankDrive(left, right); // 
		updateOperatorInterface();
	}
	
	public void startRecording() {
		recordedPath = RecordedPath.start();
	}
	
	public RecordedPath stopRecording() {
		RecordedPath p = this.recordedPath;
		this.recordedPath = null;
		return p;
	}

	public void log(double left, double right) {
		if (isRecording()) {
			recordedPath.add(left, right);
		}
	}
	
	public void drive(double magnitude, double curve) {
		// Here we reverse magnitude, because the motors are inverted on our bot
		double clipped = Math.max(Calibration.MIN_SPEED, Math.min(Calibration.MAX_SPEED, magnitude));
		robotDrive.drive(-clipped, curve);		
		updateOperatorInterface();
	}

	public void drive(double speed) {
		drive(speed, 0);
	}

	public void rotate(int dir, double speed) {
		drive(speed, dir < 0 ? -1 : 1);
	}

	public void rotateClockwise(double speed) {
		rotate(-1, speed);
	}

	public void rotateCounterClockwise(double speed) {
		rotate(1, speed);
	}

	public void driveStraight(double speed) {
		// see http://wpilib.screenstepslive.com/s/3120/m/7912/l/85772-gyros-to-control-robot-driving-direction
		double angle = getAngle(); 
		double rot = -angle * gyroSensitivity * gyroGain;
		rot = Math.min(1, Math.max(-1, rot));// between -1 and 1
		drive(speed, rot);    	
	}

	public void turnInPlace(double speed) {
		tankDrive(speed, -speed);
	}

	public void tankDrive(double lspeed, double rspeed) {
		robotDrive.tankDrive(lspeed, rspeed);
	}

	public void tankDrive(double speed) {
		tankDrive(speed, speed);
	}	
	
	public void setLeftRightMotorOutputs(double leftOutput, double rightOutput) {				
		setMotors(ControlMode.PercentOutput, leftOutput, rightOutput);
//		this.robotDrive.setLeftRightMotorOutputs(leftOutput, rightOutput);
	}
	
	public void arcadeDrive(Joystick stick) {
		robotDrive.arcadeDrive(stick);
		updateOperatorInterface();		
	}

	public void arcadeDrive(double y, double x) {
		// TODO Auto-generated method stub
		robotDrive.arcadeDrive(y, x, true);
		updateOperatorInterface();		
	}
	
	public void stop() {
		stopAll();
	}

	public double getAngle() {
		return analogGyro.getAngle();
	}

	public double getAngleRadians() {
		return Math.toRadians(getAngle());
	}

	public void init() {
		robotDrive.setSafetyEnabled(false);
	}

	public void setTrim(double d) {
		this.trim = Math.min(1, Math.abs(d));
	}
	
//	public void controlHeading(double angleInRadians) {
//		stopAll();
//		headingPID.setSetpoint(angleInRadians);
//		headingPID.enable();
//	}
//
//	public boolean isOnHeadingTarget() {
//		return headingPID.onTarget();
//	}
	
	public void controlPath(PathContainer pathContainer) {
		stopAll();		
        configureSpeedControl();
        RobotState.getInstance().resetDistanceDriven();
        mPathFollower = new PathFollower(pathContainer.buildPath(), pathContainer.isReversed(),
                new PathFollower.Parameters(
                        new Lookahead(Constants.kMinLookAhead, Constants.kMaxLookAhead,
                                Constants.kMinLookAheadSpeed, Constants.kMaxLookAheadSpeed),
                        Constants.kInertiaSteeringGain, Constants.kPathFollowingProfileKp,
                        Constants.kPathFollowingProfileKi, Constants.kPathFollowingProfileKv,
                        Constants.kPathFollowingProfileKffv, Constants.kPathFollowingProfileKffa,
                        Constants.kPathFollowingMaxVel, Constants.kPathFollowingMaxAccel,
                        Constants.kPathFollowingGoalPosTolerance, Constants.kPathFollowingGoalVelTolerance,
                        Constants.kPathStopSteeringDistance));
        mDriveControlState = DriveControlState.PATH_FOLLOWING;
	}

	
	public void idle() {
		setPercentOutput(0,0);
	}
	
	public void setPercentOutput(double left, double right) {
		setMotors(ControlMode.PercentOutput, left, right);
	}
	
	public void stopAll() {
		stopAnyFeedbackControl();
		stopRecording();
		idle();
		updateOperatorInterface();		
	}
	
	public void setMotors(ControlMode mode, double left, double right) {
		stopAnyFeedbackControl();
		mDriveControlState = DriveControlState.OPEN_LOOP;
		leftMaster.set(mode, left);
		rightMaster.set(mode, right);
	}
	
	private void stopAnyFeedbackControl() {
		if (mPathFollower != null && !mPathFollower.isFinished()) {
			mPathFollower.forceFinish();
		}
//		headingPID.disable();
	}
	
	/**
	 * Trims motor speed output by this factor. 
	 * 
	 * @see setTrim()
	 */
	public double getTrim() {
		return this.trim;
	}
	
	public void resetEncoders() {		
		this.quadratureEncoderLeft.reset();		
		this.quadratureEncoderRight.reset();
		
		updateOperatorInterface();
	}

	public void doTimerDelay() {
		Timer.delay(this.getTimerDelay());
	}
	
	public void resetGyro() {
		this.analogGyro.reset();
		this.updateOperatorInterface();
	}

	public double getLeftEncoderValue() {
		return this.quadratureEncoderLeft.getDistance();
	}

	public double getRightEncoderValue() {
		return this.quadratureEncoderRight.getDistance();
	}

	/**
	 * @deprecated
	 */
	public void updateDashboard() {
		this.updateOperatorInterface();
	}

	public void resetAll() {
		// followers should follow
		leftMaster.set(ControlMode.PercentOutput,0);
		rightMaster.set(ControlMode.PercentOutput,0);
		resetEncoders();
		resetGyro();		
		setTrim(1);
		updateOperatorInterface();		
	}
	
	@Override
	public void updateOperatorInterface() {		
		SmartDashboard.putNumber(DASHBOARD_LEFT_ENCODER_DPP,this.quadratureEncoderLeft.getDistancePerPulse());
		SmartDashboard.putNumber(DASHBOARD_RIGHT_ENCODER_DPP,this.quadratureEncoderRight.getDistancePerPulse());
		SmartDashboard.putNumber(DASHBOARD_LEFT_WHEEL_DISTANCE,this.getLeftEncoderValue());
		SmartDashboard.putNumber(DASHBOARD_RIGHT_WHEEL_DISTANCE,this.getRightEncoderValue());
		SmartDashboard.putNumber(DASHBOARD_GYRO_ANGLE, this.getAngle());	
	}

	public double getGyroSensitivity() {
		return this.gyroSensitivity;
	}

	public double[] getPositionAndVelocity() {
		return new double[] {
				getLeftEncoderValue(),				
				getLeftMotor().getSelectedSensorVelocity(0),
				getRightEncoderValue(),
				getRightMotor().getSelectedSensorVelocity(0),
				getAngleRadians()
		};
		
	}
	
	public boolean isRecording() {
		return recordedPath != null;
	}

	interface Log {
		void log(double left, double right);
	}
	
	static class MyRobotDrive extends RobotDrive {
		DriveLineLog log = null;
		public MyRobotDrive(DriveLineLog log, SpeedController leftMasterMotor, SpeedController rearLeftMotor, SpeedController rightMasterMotor,
				SpeedController rearRightMotor) {
			super(leftMasterMotor, rearLeftMotor, rightMasterMotor, rearRightMotor);
			this.log = log;			
		}

		@Override
		public void setLeftRightMotorOutputs(double leftOutput, double rightOutput) {
			if (log != null) {
			double trim = log.getTrim();
				leftOutput *= trim;
				rightOutput *= trim;
			}
			super.setLeftRightMotorOutputs(leftOutput, rightOutput);
			if (log != null) {
				log.log(leftOutput, rightOutput);				
			}
		}

	}

	//////////////////////////////////////////////////////
	// The following is adapted from Team 254 2017 code
	//
	Path mCurrentPath = null;
	boolean mIsBrakeMode = false;
    private PathFollower mPathFollower;
		

    /**
     * Check if the drive talons are configured for velocity control
     */
    protected static boolean usesTalonVelocityControl(DriveControlState state) {
        if (state == DriveControlState.VELOCITY_SETPOINT || state == DriveControlState.PATH_FOLLOWING) {
            return true;
        }
        return false;
    }

    /**
     * Check if the drive talons are configured for position control
     */
    protected static boolean usesTalonPositionControl(DriveControlState state) {
        if (state == DriveControlState.TURN_TO_HEADING) {
            return true;
        }
        return false;
    }

    /**
     * Configures talons for velocity control
     */
    void configureSpeedControl() {
            // We entered a velocity control state.
    		setMotors(ControlMode.Velocity, 0, 0);
    		
//            mLeftMaster.changeControlMode(CANTalon.TalonControlMode.Speed);
//            mLeftMaster.setNominalClosedLoopVoltage(12.0);
//            mLeftMaster.setProfile(kHighGearVelocityControlSlot);
//            mLeftMaster.configNominalOutputVoltage(Constants.kDriveHighGearNominalOutput,
//                    -Constants.kDriveHighGearNominalOutput);
//            mRightMaster.changeControlMode(CANTalon.TalonControlMode.Speed);
//            mRightMaster.setNominalClosedLoopVoltage(12.0);
//            mRightMaster.setProfile(kHighGearVelocityControlSlot);
//            mRightMaster.configNominalOutputVoltage(Constants.kDriveHighGearNominalOutput,
//                    -Constants.kDriveHighGearNominalOutput);
    		setBrakeMode(true);
        
    }
    
    /**
     * Start up velocity mode. This sets the drive train in high gear as well.
     * 
     * @param left_inches_per_sec
     * @param right_inches_per_sec
     */
    public synchronized void setVelocitySetpoint(double left_inches_per_sec, double right_inches_per_sec) {
    		configureSpeedControl();
    		
        mDriveControlState = DriveControlState.VELOCITY_SETPOINT;
        updateVelocitySetpoint(left_inches_per_sec, right_inches_per_sec);
    }

    /**
     * Adjust Velocity setpoint (if already in velocity mode)
     * 
     * @param left_inches_per_sec
     * @param right_inches_per_sec
     */
    protected synchronized void updateVelocitySetpoint(double left_inches_per_sec, double right_inches_per_sec) {
        final double max_desired = Math.max(Math.abs(left_inches_per_sec), Math.abs(right_inches_per_sec));
        final double scale = max_desired > DriveConstants.kDriveHighGearMaxSetpoint
                ? DriveConstants.kDriveHighGearMaxSetpoint / max_desired : 1.0;
        setMotors(ControlMode.Velocity, DriveUtils.inchesPerSecondToRpm(left_inches_per_sec * scale), DriveUtils.inchesPerSecondToRpm(right_inches_per_sec * scale));
    }

    /**
     * Configure talons for open loop control
     */
    public synchronized void setOpenLoop(DriveSignal signal) {
        if (mDriveControlState != DriveControlState.OPEN_LOOP) {
            mDriveControlState = DriveControlState.OPEN_LOOP;
            setBrakeMode(false);
        }
        
        setMotors(ControlMode.PercentOutput, signal.getLeft(), signal.getRight());
    }
    
    public boolean isBrakeMode() {
        return mIsBrakeMode;
    }

    public synchronized void setBrakeMode(boolean on) {
        if (mIsBrakeMode != on) {
            mIsBrakeMode = on;
            NeutralMode mode = on ? NeutralMode.Brake : NeutralMode.Coast;
            rightMaster.setNeutralMode(mode);
            rightSlave.setNeutralMode(mode);
            leftMaster.setNeutralMode(mode);
            leftSlave.setNeutralMode(mode);
        }
    }

    /**
     * Adjust position setpoint (if already in position mode)
     * 
     * @param left_inches_per_sec
     * @param right_inches_per_sec
     */
    private synchronized void updatePositionSetpoint(double left_position_inches, double right_position_inches) {
        if (usesTalonPositionControl(mDriveControlState)) {
        		setMotors(ControlMode.Position, DriveUtils.inchesToRotations(left_position_inches), 
        						DriveUtils.inchesToRotations(right_position_inches));
        } else {
            System.out.println("Hit a bad position control state");
            idle();
        }
    }

    public double getLeftDistanceInches() {
        return DriveUtils.rotationsToInches(leftMaster.getSensorCollection().getQuadraturePosition());
    }

    public double getRightDistanceInches() {
        return DriveUtils.rotationsToInches(rightMaster.getSensorCollection().getQuadraturePosition());
    }

    public double getLeftVelocityInchesPerSec() {
        return DriveUtils.rpmToInchesPerSecond(leftMaster.getSensorCollection().getQuadratureVelocity());
    }

    public double getRightVelocityInchesPerSec() {
        return DriveUtils.rpmToInchesPerSecond(rightMaster.getSensorCollection().getQuadratureVelocity());
    }

    public synchronized Rotation2d getGyroAngle() {
        return Rotation2d.identity().rotateBy(Rotation2d.fromDegrees(analogGyro.getAngle()));
    }

//    public synchronized void setGyroAngle(Rotation2d angle) {
//        mNavXBoard.setAngleAdjustment(angle);
//    }

//    public synchronized double getGyroVelocityDegreesPerSec() {
//        return mNavXBoard.getYawRateDegreesPerSec();
//    }

    
    // The robot drivetrain's various states.
    public enum DriveControlState {
        OPEN_LOOP, // open loop percentage control
        VELOCITY_SETPOINT, // velocity PID control
        PATH_FOLLOWING, // used for autonomous driving
        TURN_TO_HEADING, // turn in place
//        DRIVE_TOWARDS_GOAL_COARSE_ALIGN, // turn to face the boiler, then DRIVE_TOWARDS_GOAL_COARSE_ALIGN
//        DRIVE_TOWARDS_GOAL_APPROACH // drive forwards until we are at optimal shooting distance
    }

    

} 

interface DriveLineLog {
	void log(double left, double right);
	double getTrim();
}

