// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc.team3543.robot.subsystems;

import org.usfirst.frc.team3543.robot.OI;
import org.usfirst.frc.team3543.robot.Robot;
import org.usfirst.frc.team3543.robot.RobotMap;
import org.usfirst.frc.team3543.robot.commands.ArcadeDriveWithJoystick;

import com.ctre.phoenix.motorcontrol.can.TalonSRX;

import edu.wpi.first.wpilibj.AnalogGyro;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 * Main DriveLine.  Packages the 4 drive CANTalons, left/right quadrature encoders and gyro
 * 
 * Note that all the commands that use the drive line use high-level methods in this
 * class, they don't tale to the RobotDrive (etc.) directly.  Putting in high-level
 * methods is a good idea because it allows you to abstract the underlying actuators
 * from the commands.
 * 
 * @author MK
 *
 */
public class DriveLine extends Subsystem {
	
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final TalonSRX cANTalon1 = RobotMap.driveLineCANTalon1;
    private final TalonSRX cANTalon2 = RobotMap.driveLineCANTalon2;
    private final TalonSRX cANTalon3 = RobotMap.driveLineCANTalon3;
    private final TalonSRX cANTalon4 = RobotMap.driveLineCANTalon4;
    private final RobotDrive robotDrive = RobotMap.driveLineRobotDrive;
    private final AnalogGyro analogGyro1 = RobotMap.driveLineAnalogGyro1;
    private final Encoder quadratureEncoderLeft = RobotMap.driveLineQuadratureEncoderLeft;
    private final Encoder quadratureEncoderRight = RobotMap.driveLineQuadratureEncoderRight;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    public double gyroSensitivity = RobotMap.GYRO_SENSITIVITY;
    public double gyroGain = RobotMap.GYRO_FEEDBACK_GAIN;

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        setDefaultCommand(new ArcadeDriveWithJoystick());
    	robotDrive.setSafetyEnabled(false);
    	
    	analogGyro1.setSensitivity(RobotMap.GYRO_SENSITIVITY);    
		this.analogGyro1.calibrate();
		
//		quadratureEncoderLeft.setDistancePerPulse(Robot.geometry.encoderDistancePerPulse);
//		quadratureEncoderRight.setDistancePerPulse(Robot.geometry.encoderDistancePerPulse);		
    }
    
    public void tankDrive(Joystick left, Joystick right) {
    		robotDrive.tankDrive(left, right); // 
    }
    
    public void drive(double magnitude, double curve) {
    	// Here we reverse magnitude, because the motors are inverted on our bot
    		robotDrive.drive(-magnitude, curve);
    }
    
    public void drive(double speed) {
    	drive(speed, 0);
    }
    
    public void rotate(int dir, double speed) {
    	drive(speed, dir < 0 ? -1 : 1);
    }
    
    public void rotateClockwise(double speed) {
    	rotate(-1, speed);
    }
    
    public void rotateCounterClockwise(double speed) {
    	rotate(1, speed);
    }
    
    public void driveStraight(double speed) {
    	// see http://wpilib.screenstepslive.com/s/3120/m/7912/l/85772-gyros-to-control-robot-driving-direction
    	double angle = getGyroAngle(); 
    	double rot = -angle * gyroSensitivity * gyroGain;
    	rot = Math.min(1, Math.max(-1, rot));// between -1 and 1
    	drive(speed, rot);    	
    }
    
    public void turnInPlace(double speed) {
    	tankDrive(speed, -speed);
    }
    
    public void tankDrive(double lspeed, double rspeed) {
    	robotDrive.tankDrive(lspeed, rspeed);
    }
    
    public void tankDrive(double speed) {
    	tankDrive(speed, speed);
    }
        
    public void arcadeDrive(Joystick stick) {
    	robotDrive.arcadeDrive(stick);
    }
    
    public void stop() {
    	robotDrive.stopMotor();
    }
    
    public double getGyroAngle() {
    	return analogGyro1.getAngle();
    }
    
    public double getGyroAngleRadians() {
    	return Math.toRadians(getGyroAngle());
    }

	public void init() {
		robotDrive.setSafetyEnabled(false);
	}

	public void resetEncoders() {
		double dpp = OI.dashboard.getWheelEncoderDistancePerPulse();	
		
		// hack
//		double leftdpp = dpp * (1-0.028);
//		double leftdpp = dpp * (1-0.038);
		double leftdpp = dpp;// * (1-0.1);
//		
//		// North Bay Calibration
		leftdpp = dpp * 24 / 30.885;
		dpp = dpp * 24 / 31.356; 
//
		this.quadratureEncoderLeft.reset();
		this.quadratureEncoderLeft.setDistancePerPulse(leftdpp);
		this.quadratureEncoderRight.reset();
		this.quadratureEncoderRight.setDistancePerPulse(dpp);
		this.updateDashboard();

	}
	
	public void resetGyro() {
		this.analogGyro1.reset();
		this.updateDashboard();
	}
	
	public double getLeftEncoderValue() {
		
		return this.quadratureEncoderLeft.getDistance();
	}
	
	public double getRightEncoderValue() {
		return this.quadratureEncoderRight.getDistance();
	}

	public void updateDashboard() {
//        OI.dashboard.putDrivelineEncoders(getLeftEncoderValue(), getRightEncoderValue());
//        OI.dashboard.putDrivelineGyro(getGyroAngle());
	}

	public void resetAll() {
		resetEncoders();
		resetGyro();		
	}
	
}


