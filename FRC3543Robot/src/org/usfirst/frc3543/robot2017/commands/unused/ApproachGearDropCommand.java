// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc3543.robot2017.commands.unused;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Logger;

import org.usfirst.frc3543.robot2017.OI;
import org.usfirst.frc3543.robot2017.Robot;
import org.usfirst.frc3543.robot2017.RobotMap;
import org.usfirst.frc3543.robot2017.World;
import org.usfirst.frc3543.robot2017.commands.DriveForwardByDistanceCommand;
import org.usfirst.frc3543.robot2017.commands.LocateGearDropUsingVisionCommand;
import org.usfirst.frc3543.robot2017.commands.RotateByAngleCommand;
import org.usfirst.frc3543.robot2017.commands.ZigZagCommand;
import org.usfirst.frc3543.robot2017.subsystems.VisionSubsystem;
import org.usfirst.frc3543.robot2017.util.GearDropConsumer;
import org.usfirst.frc3543.robot2017.util.GearDropProvider;

import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.command.CommandGroup;
import edu.wpi.first.wpilibj.command.Scheduler;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import ttfft.vision.GearDrop;

import ttfft.vision.Settings;


/**
 * This is a command group where we continually add a sequential command when the current command finishes,
 * unless there are no more commands to run.
 * 
 * The evaluateNextCommand examines the situation and queues the next one
 * 
 */
public class ApproachGearDropCommand extends CommandGroup implements GearDropConsumer, GearDropProvider {
	
	public static final Logger LOGGER = Logger.getLogger(ApproachGearDropCommand.class.getSimpleName());
	
	public static final double MAX_SKEW_DEGREES = 5;	// degress from straight-on
	public static final double MIN_OFFSET = 2;	// offset in inches from center
	public static final long MAX_GEARDROP_AGE = 300;	// milliseconds
	public static final long DEFAULT_MAX_SEARCH_TIME = 15000;	// 15 seconds
	public static final double SEARCH_ANGLE_DEGREES = 5;	// degrees to turn while searching
	
	public static final double CUTOFF_DISTANCE = 36;	// inches - outside this the robot will stop here and check again if it is on track
	public static final double CUTOFF_DISTANCE_TARGET = 24;	// inches
	
	protected int lastSearchAngleCtr = 0;
	public static final double MAX_SPEED = RobotMap.MAX_SPEED;
	public static final double MIN_SPEED = RobotMap.MIN_SPEED;
	
	private boolean finished = false;
	GearDropConsumer gearDropConsumer = null;
	GearDrop gearDrop = null;
	
	// here are all the commands we use in this ChainedCommand
	Command currentCommand = null;
	DriveForwardByDistanceCommand driveForward;
	LocateGearDropUsingVisionCommand locateGearDrop;
	ScanForGearDropCommand scanForGearDrop;
	ZigZagCommand alignToGearDrop;	
	RotateByAngleCommand rotator;
	
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
 
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
    public ApproachGearDropCommand() {

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.visionSubsystem);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.driveLine);
        
        driveForward = new DriveForwardByDistanceCommand(0);
        locateGearDrop = new LocateGearDropUsingVisionCommand(5, this);
//        scanForGearDrop = new ScanForGearDropCommand(Math.toRadians(10), this);
        alignToGearDrop = new ZigZagCommand(0, 0);
//        rotator = new RotateByAngleCommand(Math.toRadians(10));
        addSequential(new LocateGearDropUsingVisionCommand(5, this));
        addSequential(alignToGearDrop);
        addSequential(new LocateGearDropUsingVisionCommand(5, this));
        addSequential(driveForward);
    }

    // Called just before this Command runs the first time
    // nothing to do really
    protected void initialize() {    	
    	super.initialize();
    	// lets just detect a gear drop
    	gearDrop = Robot.visionSubsystem.detectGearDrop();
    	if (gearDrop != null) {
    		double angle = computeAngleToGearDropPerpendicular(gearDrop) / 2; // half the angle
    		double distance = Math.abs(gearDrop.offsetFromCenter /  Math.cos(angle));
    		alignToGearDrop.setAngle(angle);
    		alignToGearDrop.setDistance(distance);
    		driveForward.setTargetDistance(gearDrop.distanceFromTarget - World.GEAR_DROP_POST + 3 - distance * Math.sin(angle));
    	}    	
//    	finished = false;
    }
    
    protected boolean gearDropIsOffsetTooMuch(GearDrop gearDrop) {
    	return Math.abs(gearDrop.offsetFromCenter) >= MIN_OFFSET;
    }

    protected void needNewGearDrop() {
    	gearDrop = null;
    }
    
    /**
     * Execute - figure out which sub-command we need to run and schedule it
     * 
     * @param current
     * @return
     */
    public void old_execute() {

    	if (currentCommand != null && currentCommand.isRunning()) {
    		LOGGER.info("Current command still running...");
    	}
    	else {
    		Command command = null; // next command we want

        	// Do we have the gear drop and is it "up to date"?
        	if (haveUpToDateGearDrop()) {
        		GearDrop gearDrop = getGearDrop();    		    		
        		
            	// If we do, figure out what to do.  
        		// if we are not facing the gear drop, turn to face it
        		
        		// if the angle we would need to turn is too great, ...
        		
        		// else turn by that angle
        		
        		// If our left/right offset is within
            	// tolerance, just drive forward at it
            	// If our left/right offset is outside tolerance, rotate, drive towards the perpendicular
            	// then rotate back again.  Then detect the gear drop again to make sure we got it right.    		

        		if (gearDropIsAngledTooMuch(gearDrop)) {
        			LOGGER.info("Gear Drop is angled too much");
        		}
        		else if (gearDropIsOffsetTooMuch(gearDrop)) {  
            		double angle = computeAngleToGearDropPerpendicular(gearDrop) / 2; // half the angle
            		double distance = Math.abs(gearDrop.offsetFromCenter /  Math.cos(angle));
            		command = new ZigZagCommand(angle, distance);
            		LOGGER.info(String.format("Need to Align to gear drop by angle %.1f distance %.1f offset %.1f", angle,distance,gearDrop.offsetFromCenter));
            	}   
            	else { // drive straight at it
            		// if distance is more than 36 inches, only go 24 inches then check again
            		// otherwise go right at it
            		double distance = gearDrop.distanceFromTarget - World.GEAR_DROP_POST * 0.6; // want the gear partway on the post or so
            		if (distance >= CUTOFF_DISTANCE) {
            			distance = distance - CUTOFF_DISTANCE;
                		setGearDrop(null); // need to detect again next time            			
            		}
            		LOGGER.info(String.format("Need to drive forward by %.1f", distance));
            		command = new DriveForwardByDistanceCommand(distance);
            	}
        	}
        	else {
            	// no gear drop. Were we just trying to locate the gearDrop?  Seems we can't.  Let's do a little scan back and forth
            	LOGGER.info("no gear drop detected");
        		if (currentCommand == locateGearDrop) { // if we just looked for the gear drop and didn't find it, rotate by a few degrees and then look again
            		// For the scan we first rotate left by SEARCH_ANGLE_DEGREES twice, 
            		// the right by SEARCH_ANGLE_DEGREES twice, to see if we can find the gear drop
            		int ctr = 0;
            		if (lastSearchAngleCtr <= -2) {
            			ctr = 3;	// rotate back then by angle
            		}
            		else if (lastSearchAngleCtr < 0) { // rotate ccw
            			ctr--;	
            		}
            		else if (lastSearchAngleCtr < 2){ // keep rotating cw
            			ctr++;
            		}
            		else {
            			// did not find
            			ctr = 0;
            		}
            		if (ctr == 0) {
            			// let's do a full rotation scan then
                		LOGGER.info("Need to scan for gear drop");

            			command = scanForGearDrop;
            		}
            		else {
                		command = rotator;
                		double angle = Math.toRadians(SEARCH_ANGLE_DEGREES * ctr);
                		LOGGER.info(String.format("Need to rotate by %.1f", angle));

                		rotator.setRotationAngle(angle);
            		}
            		lastSearchAngleCtr = ctr;
            	}    	
            	else if (currentCommand == scanForGearDrop) {
            		// could not find it, oh well, I guess we stop?
            		command = null;
            	}
            	else { // try to detect gear drop
            		LOGGER.info("Need to locate gear drop");
                	command = locateGearDrop; // first, find the geardrop
            	}    	    		
        	}
        	if (command != null) {
        		LOGGER.info("Scheduling new command: "+command.getClass().getSimpleName());
        		Scheduler.getInstance().add(command);        		
        	}
        	else {
        		finished = true;
        	}
        	currentCommand = command;
    	}

    	if (currentCommand != null) {
    		SmartDashboard.putString(OI.GEARFINDER_MODE, currentCommand.getClass().getSimpleName());
    	}
    	else {
    		SmartDashboard.putString(OI.GEARFINDER_MODE, "NONE");
    	}
    	
    }
    
    protected boolean gearDropIsAngledTooMuch(GearDrop gearDrop) {
    	// TODO - get the angle based on the difference in size of the two blobs
    	return Math.abs(gearDrop.skewAngle) > Math.toRadians(MAX_SKEW_DEGREES); // five degrees?
//    	return false;
	}

    protected boolean haveUpToDateGearDrop() {
    	LOGGER.info("haveUpToDateGearDrop: "+(gearDrop != null));
    	return gearDrop != null; //&& (System.currentTimeMillis() - gearDrop.timestamp < MAX_GEARDROP_AGE);
	}

	protected double computeAngleToGearDropPerpendicular(GearDrop gearDrop) {
		double d = gearDrop.distanceFromTarget;
		double x = gearDrop.offsetFromCenter;
		return Math.asin(x/d);
    }
    
    public GearDrop getGearDrop() {
    	return gearDrop;
    }    
    
//    protected void approachGearDrop() {
//		double speed = 0;
//		double curve = 0;
//		double curveGain = SmartDashboard.getNumber(OI.GEARFINDER_CURVE_GAIN, RobotMap.GEAR_APPROACH_CURVE_GAIN);
//		double speedGain = SmartDashboard.getNumber(OI.GEARFINDER_SPEED_GAIN, RobotMap.GEAR_APPROACH_SPEED_GAIN);
//
//		if (gearDrop == null) {
//			LOGGER.info("No gear drop");	
//			return;
//		}
//		else {
//			
//			// as a percentage
//			speed = (gearDrop.distanceFromTarget - Settings.TARGET_DISTANCE_IN_M) * speedGain;
//			
//			speed =  Math.max(- MAX_SPEED, Math.min(MAX_SPEED,  speed));	
//			
//			if (speed > 0) speed = Math.max(speed, MIN_SPEED);
//			else if (speed < 0) speed = Math.min(speed, -MIN_SPEED);
//			
//			// is it offset left? turn CCW meaning increase right speed and decrease left		
//			// is it offset right? turn CW meaning increase left speed and decrease right		
//			// max turn speed at 1/4 width
//	
//			curve += Math.max(-1, Math.min(1, -gearDrop.offsetAsPercentage[0] * curveGain ));
//			
//			// is left side smaller?  turn CW if leftRightSizeDiff < 1
//			// is right side smaller?  turn CCW if leftRightSizeDiff > 1
//			// max turn speed at +/-25%
//	//			curve += Math.max(1, Math.min(-1, (1 - gearDrop.leftRightSizeDiff) * 4));
//			
//			LOGGER.info(String.format("Drive at %.1f curve %.1f", -speed, curve));
//			Robot.driveLine.drive(-speed, curve);
//		}
//
//	}
       
	@Override
	public void setGearDrop(GearDrop gearDrop) {
		this.gearDrop = gearDrop;	
		LOGGER.info("SET GEAR DROP: "+(gearDrop != null));
		if (gearDropConsumer != null) {
			gearDropConsumer.setGearDrop(gearDrop);
		}
	}

	@Override
	public void setGearDropConsumer(GearDropConsumer c) {
		this.gearDropConsumer = c;
	}

//	@Override
//	protected boolean isFinished() {
//		return finished;
//	}

}
