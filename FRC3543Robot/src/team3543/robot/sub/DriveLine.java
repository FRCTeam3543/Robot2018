// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package team3543.robot.sub;

import java.util.Optional;

import org.usfirst.frc.team3543.robot.Calibration;
import org.usfirst.frc.team3543.robot.Wiring;

import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.NeutralMode;
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
import com.team254.frc2017.Constants;
import com.team254.frc2017.Kinematics;
import com.team254.frc2017.RobotState;
import com.team254.frc2017.subsystems.Drive;
import com.team254.frc2017.subsystems.Drive.DriveControlState;
import com.team254.lib.util.DriveSignal;
import com.team254.lib.util.control.Lookahead;
import com.team254.lib.util.control.PathContainer;
import com.team254.lib.util.control.PathFollower;
import com.team254.lib.util.drivers.NavX;
import com.team254.lib.util.math.RigidTransform2d;
import com.team254.lib.util.math.Rotation2d;
import com.team254.lib.util.math.Twist2d;
import com.usfirst.frc.team3543.robot.pathrecording.RecordedPath;
import com.team254.lib.util.control.Path;

import edu.wpi.first.wpilibj.AnalogGyro;
import edu.wpi.first.wpilibj.CounterBase.EncodingType;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.PIDController;
import edu.wpi.first.wpilibj.PIDSourceType;
import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.command.PIDSubsystem;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import team3543.robot.ann.Dashboard;
import team3543.robot.cal.PIDF;
import team3543.robot.sub.drive.DriveConstants;
import team3543.robot.sub.drive.DriveState;
import team3543.robot.sub.drive.DriveUtils;


/**
 * Main DriveLine.  Packages the 4 drive CANTalons, left/right quadrature encoders and gyro
 * 
 * Note that all the commands that use the drive line use high-level methods in this
 * class, they don't tale to the RobotDrive (etc.) directly.  Putting in high-level
 * methods is a good idea because it allows you to abstract the underlying actuators
 * from the commands.
 * 
 * @author MK
 *
 */
@SuppressWarnings("deprecation")
@Dashboard
public class DriveLine extends Subsystem implements DriveLineLog {
	///////////// Calibration
	public static double gyroSensitivity 	= 0.007;
	public static double encoderDPP 			= 0.0131;
	public static double openLoopRamp 		= 0.5;
	public static PIDF 	headingPID 			= new PIDF();
	
	///////////// Wiring
	public static int leftMasterMotorPort 	= 1;
	public static int leftSlaveMotorPort 	= 2;
	public static int rightMasterMotorPort 	= 3;
	public static int rightSlaveMotorPort 	= 4;

	public static int leftMasterEncoderPort 	= 1;
	public static int leftSlaveEncoderPort 	= 2;
	public static int rightMasterEncoderPort 	= 3;
	public static int rightSlaveEncoderPort 	= 4;
	
	public static int gyroPort				= 9;
	
	////////////// Components
	private WPI_TalonSRX leftMaster;
	private WPI_TalonSRX leftSlave;
	private WPI_TalonSRX rightMaster;
	private WPI_TalonSRX rightSlave;
	private RobotDrive robotDrive;
	private AnalogGyro analogGyro;
	private Encoder quadratureEncoderLeft;
	private Encoder quadratureEncoderRight;
	
	///////////// Telemetry/odometry
	private DriveState driveState;
	
	private double trim = 1.0;
		
	private DriveControlState mDriveControlState;

	private RecordedPath recordedPath = null;
		
	public DriveLine() {
		super();

		leftMaster = new WPI_TalonSRX(leftMasterMotorPort);       
		leftSlave = new WPI_TalonSRX(leftSlaveMotorPort);		
		leftSlave.follow(leftMaster);
		leftMaster.setNeutralMode(NeutralMode.Brake);		
		leftMaster.configOpenloopRamp(openLoopRamp, 0);		
		leftSlave.configOpenloopRamp(openLoopRamp, 0);		
		leftMaster.set(ControlMode.PercentOutput,0);
			
		rightMaster = new WPI_TalonSRX(rightMasterMotorPort);
		rightSlave = new WPI_TalonSRX(rightSlaveMotorPort);		
		rightSlave.follow(rightMaster);				
		rightMaster.setNeutralMode(NeutralMode.Brake);
		rightMaster.configOpenloopRamp(openLoopRamp, 0);
		rightSlave.configOpenloopRamp(openLoopRamp, 0);		
		rightMaster.set(ControlMode.PercentOutput,0);
						
		robotDrive = new MyRobotDrive(this, leftMaster, leftSlave, rightMaster, rightSlave);		
		robotDrive.setSafetyEnabled(true);

		analogGyro = new AnalogGyro(gyroPort);
		analogGyro.setSensitivity(gyroSensitivity);
						
		quadratureEncoderLeft = new Encoder(leftMasterEncoderPort, leftSlaveEncoderPort, false, EncodingType.k2X);	    	
		quadratureEncoderLeft.setDistancePerPulse(encoderDPP);
		quadratureEncoderLeft.setPIDSourceType(PIDSourceType.kRate);

		quadratureEncoderRight = new Encoder(rightMasterEncoderPort, rightSlaveEncoderPort, false, EncodingType.k2X);
		quadratureEncoderRight.setDistancePerPulse(encoderDPP);
		quadratureEncoderRight.setPIDSourceType(PIDSourceType.kRate);		
		
		driveState = new DriveState(this);
	}

	private WPI_TalonSRX getLeftMotor() {
		return this.leftMaster;
	}
	
	private WPI_TalonSRX getRightMotor() {
		return this.rightMaster;
	}
		
	public void initDefaultCommand() {
	}
	
	//
	/////////////////////////// Resets and Calibration ///////////////////////////////
	//
	
	private void stopAnyFeedbackControl() {
		if (mPathFollower != null && !mPathFollower.isFinished()) {
			mPathFollower.forceFinish();
		}
	}
	
	/**
	 * Trims motor speed output by this factor. 
	 * 
	 * @see setTrim()
	 */
	public double getTrim() {
		return this.trim;
	}
	
	public void resetEncoders() {		
		this.quadratureEncoderLeft.reset();		
		this.quadratureEncoderRight.reset();		
	}
	
	public void calibrateGyro() {
		this.analogGyro.calibrate(); 	
	}
	
	public void resetGyro() {
		this.analogGyro.reset();
	}

	public void resetAll() {
		// followers should follow
		setMotors(ControlMode.PercentOutput, 0, 0);
		resetEncoders();
		resetGyro();		
		setTrim(1);
		driveState.resetDistanceDriven();
	}
	
	// telemetry
	public DriveState getDriveState() {
		return driveState;
	}
	
	//
	////////////////////////////// Sensors /////////////////////////////////
	//
		
	public double getAngle() {
		return analogGyro.getAngle();
	}
	
	public double getHeading() {
		return getAngleRadians();
	}

	public double getAngleRadians() {
		return Math.toRadians(getAngle());
	}

	public double getLeftEncoderValue() {
		return this.quadratureEncoderLeft.getDistance();
	}

	public double getRightEncoderValue() {
		return this.quadratureEncoderRight.getDistance();
	}
	
	public AnalogGyro getGyro() {
		return this.analogGyro;
	}
	
	//
	////////////////////// Basic Open Loop Driving /////////////////////////
	//
	public void stop() {
		stopAll();
	}

	public void drive(double magnitude, double curve) {
		// Here we reverse magnitude, because the motors are inverted on our bot
		double clipped = Math.max(Calibration.MIN_SPEED, Math.min(Calibration.MAX_SPEED, magnitude));
		robotDrive.drive(-clipped, curve);		
	}

	public void drive(double speed) {
		drive(speed, 0);
	}

	public void rotate(int dir, double speed) {
		drive(speed, dir < 0 ? -1 : 1);
	}

	public void rotateClockwise(double speed) {
		rotate(-1, speed);
	}

	public void rotateCounterClockwise(double speed) {
		rotate(1, speed);
	}

	public void driveStraight(double speed) {
		// see http://wpilib.screenstepslive.com/s/3120/m/7912/l/85772-gyros-to-control-robot-driving-direction
		double angle = getAngle(); 
		double rot = -angle * gyroSensitivity;
		rot = Math.min(1, Math.max(-1, rot));// between -1 and 1
		drive(speed, rot);    	
	}

	public void turnInPlace(double speed) {
		tankDrive(speed, -speed);
	}

	public void tankDrive(double lspeed, double rspeed) {
		robotDrive.tankDrive(lspeed, rspeed);
	}

	public void tankDrive(double speed) {
		tankDrive(speed, speed);
	}	
	
	public void tankDrive(Joystick left, Joystick right) {
		robotDrive.tankDrive(left, right); // 
	}	
	
	public void setLeftRightMotorOutputs(double leftOutput, double rightOutput) {				
		setMotors(ControlMode.PercentOutput, leftOutput, rightOutput);
//		this.robotDrive.setLeftRightMotorOutputs(leftOutput, rightOutput);
	}
	
	public void arcadeDrive(Joystick stick) {
		robotDrive.arcadeDrive(stick);
	}

	public void arcadeDrive(double y, double x) {
		// TODO Auto-generated method stub
		robotDrive.arcadeDrive(y, x, true);
	}
	
	public void setTrim(double d) {
		this.trim = Math.min(1, Math.abs(d));
	}
	
	public void idle() {
		setPercentOutput(0,0);
	}
	
	public void setPercentOutput(double left, double right) {
		setMotors(ControlMode.PercentOutput, left, right);
	}
	
	public void stopAll() {
		stopAnyFeedbackControl();
		stopRecording();
		idle();
	}
	
	public void setMotors(ControlMode mode, double left, double right) {
		stopAnyFeedbackControl();
		mDriveControlState = DriveControlState.OPEN_LOOP;
		leftMaster.set(mode, left);
		rightMaster.set(mode, right);
	}
	
//	@Override
//	public void updateOperatorInterface() {		
//		SmartDashboard.putNumber(DASHBOARD_LEFT_ENCODER_DPP,this.quadratureEncoderLeft.getDistancePerPulse());
//		SmartDashboard.putNumber(DASHBOARD_RIGHT_ENCODER_DPP,this.quadratureEncoderRight.getDistancePerPulse());
//		SmartDashboard.putNumber(DASHBOARD_LEFT_WHEEL_DISTANCE,this.getLeftEncoderValue());
//		SmartDashboard.putNumber(DASHBOARD_RIGHT_WHEEL_DISTANCE,this.getRightEncoderValue());
//		SmartDashboard.putNumber(DASHBOARD_GYRO_ANGLE, this.getAngle());	
//	}

	public double[] getPositionAndVelocity() {
		return new double[] {
				getLeftEncoderValue(),				
				getLeftMotor().getSelectedSensorVelocity(0),
				getRightEncoderValue(),
				getRightMotor().getSelectedSensorVelocity(0),
				getAngleRadians()
		};
		
	}
	
	public boolean isRecording() {
		return recordedPath != null;
	}

	interface Log {
		void log(double left, double right);
	}

	//
	/////////////// Path Recording /////////////
	//
	public void log(double left, double right) {
		if (isRecording()) {
			recordedPath.add(left, right);
		}
	}
	
	/**
	 * Start recording outputs
	 */
	public void startRecording() {
		recordedPath = RecordedPath.start();
	}
	
	/**
	 * Stop recording outputs and return the path data
	 * @return
	 */
	public RecordedPath stopRecording() {
		RecordedPath p = this.recordedPath;
		this.recordedPath = null;
		return p;
	}
	
	//////////////////////////////////////////////////////
	// The following is adapted from Team 254 2017 code
	//
	Path mCurrentPath = null;
	boolean mIsBrakeMode = false;
    private PathFollower mPathFollower;
		

    /**
     * Check if the drive talons are configured for velocity control
     */
    protected static boolean usesTalonVelocityControl(DriveControlState state) {
        if (state == DriveControlState.VELOCITY_SETPOINT || state == DriveControlState.PATH_FOLLOWING) {
            return true;
        }
        return false;
    }

    /**
     * Check if the drive talons are configured for position control
     */
    protected static boolean usesTalonPositionControl(DriveControlState state) {
        if (state == DriveControlState.TURN_TO_HEADING) {
            return true;
        }
        return false;
    }

    /**
     * Configures talons for velocity control
     */
    public void configureSpeedControl() {
            // We entered a velocity control state.
    		setMotors(ControlMode.Velocity, 0, 0);
    		
//            mLeftMaster.changeControlMode(CANTalon.TalonControlMode.Speed);
//            mLeftMaster.setNominalClosedLoopVoltage(12.0);
//            mLeftMaster.setProfile(kHighGearVelocityControlSlot);
//            mLeftMaster.configNominalOutputVoltage(Constants.kDriveHighGearNominalOutput,
//                    -Constants.kDriveHighGearNominalOutput);
//            mRightMaster.changeControlMode(CANTalon.TalonControlMode.Speed);
//            mRightMaster.setNominalClosedLoopVoltage(12.0);
//            mRightMaster.setProfile(kHighGearVelocityControlSlot);
//            mRightMaster.configNominalOutputVoltage(Constants.kDriveHighGearNominalOutput,
//                    -Constants.kDriveHighGearNominalOutput);
    		setBrakeMode(true);
        
    }
    
    /**
     * Start up velocity mode. This sets the drive train in high gear as well.
     * 
     * @param left_inches_per_sec
     * @param right_inches_per_sec
     */
    public synchronized void controlVelocity() {
    		configureSpeedControl();    		
        mDriveControlState = DriveControlState.VELOCITY_SETPOINT;
        controlVelocity(0, 0);
    }

    /**
     * Adjust Velocity setpoint (if already in velocity mode)
     * 
     * @param left_inches_per_sec
     * @param right_inches_per_sec
     */
    public synchronized void controlVelocity(double left_inches_per_sec, double right_inches_per_sec) {
        final double max_desired = Math.max(Math.abs(left_inches_per_sec), Math.abs(right_inches_per_sec));
        final double scale = max_desired > DriveConstants.kDriveHighGearMaxSetpoint
                ? DriveConstants.kDriveHighGearMaxSetpoint / max_desired : 1.0;
        setMotors(ControlMode.Velocity, DriveUtils.inchesPerSecondToRpm(left_inches_per_sec * scale), DriveUtils.inchesPerSecondToRpm(right_inches_per_sec * scale));
    }

    /**
     * Configure talons for open loop control
     */
    public synchronized void setOpenLoop(DriveSignal signal) {
        if (mDriveControlState != DriveControlState.OPEN_LOOP) {
            mDriveControlState = DriveControlState.OPEN_LOOP;
            setBrakeMode(false);
        }
        
        setMotors(ControlMode.PercentOutput, signal.getLeft(), signal.getRight());
    }
    
    public boolean isBrakeMode() {
        return mIsBrakeMode;
    }

    public synchronized void setBrakeMode(boolean on) {
        if (mIsBrakeMode != on) {
            mIsBrakeMode = on;
            NeutralMode mode = on ? NeutralMode.Brake : NeutralMode.Coast;
            rightMaster.setNeutralMode(mode);
            rightSlave.setNeutralMode(mode);
            leftMaster.setNeutralMode(mode);
            leftSlave.setNeutralMode(mode);
        }
    }

    /**
     * Adjust position setpoint (if already in position mode)
     * 
     * @param left_inches_per_sec
     * @param right_inches_per_sec
     */
    private synchronized void updatePositionSetpoint(double left_position_inches, double right_position_inches) {
        if (usesTalonPositionControl(mDriveControlState)) {
        		setMotors(ControlMode.Position, DriveUtils.inchesToRotations(left_position_inches), 
        						DriveUtils.inchesToRotations(right_position_inches));
        } else {
            System.out.println("Hit a bad position control state");
            idle();
        }
    }

    public double getLeftDistanceInches() {
        return DriveUtils.rotationsToInches(leftMaster.getSensorCollection().getQuadraturePosition());
    }

    public double getRightDistanceInches() {
        return DriveUtils.rotationsToInches(rightMaster.getSensorCollection().getQuadraturePosition());
    }

    public double getLeftVelocityInchesPerSec() {
        return DriveUtils.rpmToInchesPerSecond(leftMaster.getSensorCollection().getQuadratureVelocity());
    }

    public double getRightVelocityInchesPerSec() {
        return DriveUtils.rpmToInchesPerSecond(rightMaster.getSensorCollection().getQuadratureVelocity());
    }

    public synchronized Rotation2d getGyroAngle() {
        return Rotation2d.identity().rotateBy(Rotation2d.fromDegrees(analogGyro.getAngle()));
    }

//    public synchronized void setGyroAngle(Rotation2d angle) {
//        mNavXBoard.setAngleAdjustment(angle);
//    }

//    public synchronized double getGyroVelocityDegreesPerSec() {
//        return mNavXBoard.getYawRateDegreesPerSec();
//    }

    
    // The robot drivetrain's various states.
    public enum DriveControlState {
        OPEN_LOOP, // open loop percentage control
        VELOCITY_SETPOINT, // velocity PID control
        PATH_FOLLOWING, // used for autonomous driving
        TURN_TO_HEADING, // turn in place
//        DRIVE_TOWARDS_GOAL_COARSE_ALIGN, // turn to face the boiler, then DRIVE_TOWARDS_GOAL_COARSE_ALIGN
//        DRIVE_TOWARDS_GOAL_APPROACH // drive forwards until we are at optimal shooting distance
    }

	static class MyRobotDrive extends RobotDrive {
		DriveLineLog log = null;
		public MyRobotDrive(DriveLineLog log, SpeedController leftMasterMotor, SpeedController rearLeftMotor, SpeedController rightMasterMotor,
				SpeedController rearRightMotor) {
			super(leftMasterMotor, rearLeftMotor, rightMasterMotor, rearRightMotor);
			this.log = log;			
		}

		@Override
		public void setLeftRightMotorOutputs(double leftOutput, double rightOutput) {
			if (log != null) {
			double trim = log.getTrim();
				leftOutput *= trim;
				rightOutput *= trim;
			}
			super.setLeftRightMotorOutputs(leftOutput, rightOutput);
			if (log != null) {
				log.log(leftOutput, rightOutput);				
			}
		}

	}    

} 

interface DriveLineLog {
	void log(double left, double right);
	double getTrim();
}

